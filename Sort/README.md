此文件目的是记录排序算法
====

|类名|描述|稳定性|时间复杂度
|:---|:---|:---|:----
|Sort|冒泡排序|稳定|O(2n)
|QuickSort|快速排序|不稳定|最坏O(2n)；平均 O(nlgn)
|InsertSort|直接插入排序|稳定|O(2n)
|ShellSort|希尔排序|不稳定|O(2n) 
|SelectionSort|选择排序|稳定|O(2n) 
|MergeSort|归并排序|稳定|最好/最坏/平均  O(nlogn)
|RadixSort|基数排序|算法稳定|平均/最差/最好 O(d(n+r))
|HeapSort|堆排序||平均/最差/最好 O(nlogn)

![sort](/sort.jpg sort)

## Sort
*冒泡排序
*算法稳定
*时间复杂度为O(2n)
## QuickSort
*快速排序  
*算法不稳定  
*时间复杂度：最坏O(2n)；平均为O(nlgn)  
*原理分析：  
		i = l = 0  
		j = len  
		x = a[i] = 3 以x为基准数，将数据根据准数左右两边排序  
		3 6 4 8 1 2 5 (范例)  
		在 i < j 的条件下循环从右往左找，从左往右找  
		从右往左找比他小的数移到左边 (i < j && a[j] > x)  循环到a[i] < x为止  
		2 6 4 8 1 2 5 (a[i++] = a[j])  
		从左往右找比他大的数移到右边 (i < j && a[i] < x)  循环到a[i] > x为止  
		2 6 4 8 1 6 5 (a[j--] = a[i]) a[2]大于x 所以复制于a[j]并且j--   
		结束 i < j 的条件下循环 ，将a[i] = x  
		继续递归快速排序 quickSort(a, l, i - 1); quickSort(a, i + 1, r);  
## InsertSort
*直接插入排序  
*算法稳定  
*时间复杂度：O(2n)  
*原理分析  
    预先定义有序数列  
		4 5 4 8 1 2  （初始）  
		4 5 4 8 1 2  （预先定义的有序数列范围0-1）  
			4  			-》 4 5  
		4 5 4 8 1 2  （预先定义的有序数列范围0-2）  
			4 5  		-》 4 4 5  
		4 5 4 8 1 2  （预先定义的有序数列范围0-3）  
			4 4 5 		-》 4 4 5 8  
		4 5 4 8 1 2  （预先定义的有序数列范围0-4）  
			4 4 5 8 	-》 1 4 4 5 8  
		4 5 4 8 1 2  （预先定义的有序数列范围0-5）  
			1 4 4 5 8 	-》 1 2 4 4 5 8  
		从以上分析可知：  
			1、预先在左边定义有序数列  
			2、无序数列中每一个元素依次在有序数列中找到合适的位置  
			3、根据合适的位置下标从尾部向前移动元素  
## ShellSort
*希尔排序 -- 缩小增量排序  
*算法不稳定  
*时间复杂度： 最坏O(1.5)；平均O(Nlog2N)  
*原理分析：  
>通过对步长不断的对半分，并且满足步长的两个元素进行比较再交换，直至步长<=1为止，会得到一个有序数列    
>while: 1 <= gap  
>>4 5 4 8 1 2  （初始）  
>>for: i = gap = 3; i < len; i++;  
>>>temp = a[i]  
>>>for: j = i-gap; j >= 0 && temp < a[j]; j = j-gap (如果符合 j >= 0 && temp < a[j] 将会一直往前替换)  
>>>>[4,4]   4 5 4 8 1 2  
>>>>[5,8]   4 5 4 8 1 2  
>>>>[4,4,1] 4 5 1 8 4 2 -》 1 5 4 8 4 2  
>>>>[5,8,2] 1 5 4 2 4 8 -》 1 2 4 5 4 8  
  
>>1 2 4 5 4 8  （初始）  
>>for: i = gap = 1; i < len; i++;  
>>>temp = a[i]  
>>>for: j = i-gap; j >= 0 && temp < a[j]; j = j-gap (如果符合 j >= 0 && temp < a[j] 将会一直往前替换)  
>>>>[1,2]   	1 2 4 5 4 8  
>>>>[1,2,4]		1 2 4 5 4 8  
>>>>[1,2,4,5] 	1 2 4 5 4 8  
>>>>[1,2,4,5,4] 1 2 4 4 5 8  
  
>从以上分析可知：  
>>1、根据长度计算出步长(gap = len/2)  
>>2、以步长为初始下标并循环递增1  
>>3、在循环中根据步长往回替换排序（此处操作类似插入排序InsertSort）  
## SelectionSort
*选择排序
*算法稳定
*时间复杂度： O(2n) 
## MergeSort
*归并排序
*算法稳定
*时间复杂度： 最好/最坏/平均 都为 O(nlogn)
## RadixSort
*基数排序
*算法稳定
*时间复杂度：平均/最差/最好 O(d(n+r))




