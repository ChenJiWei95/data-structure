此文件目的是记录排序算法
====

|类名|描述|稳定性|时间复杂度
|:---|:---|:---|:----
|Sort|冒泡排序|稳定|O(2n)
|QuickSort|快速排序|不稳定|最坏O(2n)；平均 O(nlgn)
|InsertSort|直接插入排序|稳定|O(2n)
|ShellSort|希尔排序|不稳定|O(2n) 
|SelectionSort|选择排序|稳定|O(2n) 
|MergeSort|归并排序|稳定|最好/最坏/平均  O(nlogn)
|RadixSort|基数排序|算法稳定|平均/最差/最好 O(d(n+r))
|HeapSort|堆排序||平均/最差/最好 O(nlogn)

![sort](/sort.jpg sort)

## Sort
*冒泡排序
*算法稳定
*时间复杂度为O(2n)
## QuickSort
*快速排序
*算法不稳定
*时间复杂度：最坏O(2n)；平均为O(nlgn)
## InsertSort
*直接插入排序  
*算法稳定  
*时间复杂度：O(2n)  
*原理分析  
    预先定义有序数列  
		4 5 4 8 1 2  （初始）  
		4 5 4 8 1 2  （预先定义的有序数列范围0-1）  
			4  			-》 4 5  
		4 5 4 8 1 2  （预先定义的有序数列范围0-2）  
			4 5  		-》 4 4 5  
		4 5 4 8 1 2  （预先定义的有序数列范围0-3）  
			4 4 5 		-》 4 4 5 8  
		4 5 4 8 1 2  （预先定义的有序数列范围0-4）  
			4 4 5 8 	-》 1 4 4 5 8  
		4 5 4 8 1 2  （预先定义的有序数列范围0-5）  
			1 4 4 5 8 	-》 1 2 4 4 5 8  
		从以上分析可知：  
			1、预先在左边定义有序数列  
			2、无序数列中每一个元素依次在有序数列中找到合适的位置  
			3、根据合适的位置下标从尾部向前移动元素  
## ShellSort
*希尔排序 -- 缩小增量排序
*算法不稳定
*时间复杂度： 最坏O(1.5)；平均O(Nlog2N)
## SelectionSort
*选择排序
*算法稳定
*时间复杂度： O(2n) 
## MergeSort
*归并排序
*算法稳定
*时间复杂度： 最好/最坏/平均 都为 O(nlogn)
## RadixSort
*基数排序
*算法稳定
*时间复杂度：平均/最差/最好 O(d(n+r))




