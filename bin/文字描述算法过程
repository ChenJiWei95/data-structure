	冒泡排序
		依次将每一个元素与其他元素比较，符合条件的元素往后移动
	快速排序 分而治之
		i = l = 0
		j = len
		x = a[i] = 3 以x为基准数，将数据根据准数左右两边排序
		3 6 4 8 1 2 5 (范例)
		在 i < j 的条件下循环从右往左找，从左往右找
		从右往左找比他小的数移到左边 (i < j && a[j] > x)  循环到a[i] < x为止
		2 6 4 8 1 2 5 (a[i++] = a[j])
		从左往右找比他大的数移到右边 (i < j && a[i] < x)  循环到a[i] > x为止
		2 6 4 8 1 6 5 (a[j--] = a[i]) a[2]大于x 所以复制于a[j]并且j--
		结束 i < j 的条件下循环 ，将a[i] = x
		继续递归快速排序 quickSort(a, l, i - 1); quickSort(a, i + 1, r);	
	直接插入排序
		预先定义有序数列
		4 5 4 8 1 2  （初始）
		4 5 4 8 1 2  （预先定义的有序数列范围0-1）
			4  			-》 4 5
		4 5 4 8 1 2  （预先定义的有序数列范围0-2）
			4 5  		-》 4 4 5
		4 5 4 8 1 2  （预先定义的有序数列范围0-3）
			4 4 5 		-》 4 4 5 8
		4 5 4 8 1 2  （预先定义的有序数列范围0-4）
			4 4 5 8 	-》 1 4 4 5 8
		4 5 4 8 1 2  （预先定义的有序数列范围0-5）
			1 4 4 5 8 	-》 1 2 4 4 5 8
		从以上分析可知：
			1、预先在左边定义有序数列
			2、无序数列中每一个元素依次在有序数列中找到合适的位置
			3、根据合适的位置下标从尾部向前移动元素
	希尔排序
		通过对步长不断的对半分，并且满足步长的两个元素进行比较再交换，直至步长<=1为止，会得到一个有序数列  
		while: 1 <= gap  
			4 5 4 8 1 2  （初始）  
			for: i = gap = 3; i < len; i++;  
				temp = a[i]
				for: j = i-gap; j >= 0 && temp < a[j]; j = j-gap (如果符合 j >= 0 && temp < a[j] 将会一直往前替换)  
					[4,4]   4 5 4 8 1 2  
					[5,8]   4 5 4 8 1 2  
					[4,4,1] 4 5 1 8 4 2 -》 1 5 4 8 4 2  
					[5,8,2] 1 5 4 2 4 8 -》 1 2 4 5 4 8  
			1 2 4 5 4 8  （初始）  
			for: i = gap = 1; i < len; i++;  
				temp = a[i]
				for: j = i-gap; j >= 0 && temp < a[j]; j = j-gap (如果符合 j >= 0 && temp < a[j] 将会一直往前替换)  
					[1,2]   	1 2 4 5 4 8  
					[1,2,4]		1 2 4 5 4 8  
					[1,2,4,5] 	1 2 4 5 4 8  
					[1,2,4,5,4] 1 2 4 4 5 8  
		从以上分析可知：
			1、根据长度计算出步长(gap = len/2)  
			2、以步长为初始下标并循环根据步长往回替换排序（此处是插入排序InsertSort）
		
	选择排序
		在未排序的数列中找到最小元素，将其放到有序数列末尾位置；接着从剩余未排序的数列中继续前面的步骤
		4 5 4 8 1 2  （初始）
		for: i = 0; i < len; i++; 构建有序数列
			for: j = i + 1; j < len; j++;
				min = 最小值下标
			if: min != i
				将最小值元素替换到有序数列末尾
		从以上分析可知：
			1、在无序（右边）的数列中找出最小的元素并插入有序（左边）数列的末端
	归并排序
		分而治之--形成一棵二叉树，后归并排序
		以下是对二叉树归并并进行排序的操作 其中一个过 程  
		4 5 4 8 1 2  （初始）
		mid = 2
		4 8 - 》 temp[4]    左边下标++
		5 8 - 》 temp[4,5]	左边下标++
		4 8 - 》 temp[4,5,4]左边下标++
		补齐右边剩余 temp[4,5,4,8,1,2]
		将temp拷贝到原数组
		从以上分析可知：
			1、先形成最细的二叉树
			2、根据最细的二叉树进行排序
		
	基数排序
		24 15 34 28 1 2  （初始）
		d = 1:
			a:24 -> count[0,0,0,0,1,0,0,0,0,0]
			a:15 -> count[0,0,0,0,1,1,0,0,0,0]
			a:34 -> count[0,0,0,0,2,1,0,0,0,0]
			a:28 -> count[0,0,0,0,2,1,0,0,1,0]
			a:1  -> count[0,1,0,0,2,1,0,0,1,0]
			a:2  -> count[0,1,1,0,2,1,0,0,1,0]
			当d = 1时，结果是    count[0,1,1,0,2,1,0,0,1,0]
			再处理形成右边界索引 count[0,1,2,2,4,5,5,5,6,6] (当前元素=前一元素+当前元素/当前元素+=前一元素)
			通过右边界索引可得bucket[1,2,24,34,15,28]
			并将bucket拷贝到a中
			
		d = 2:
			a:1 ->  count[1,0,0,0,0,0,0,0,0,0]
			a:2 ->  count[2,0,0,0,0,0,0,0,0,0]
			a:24 -> count[2,0,1,0,0,0,0,0,0,0]
			a:34 -> count[2,0,1,1,0,0,0,0,0,0]
			a:15 -> count[2,1,1,1,0,0,0,0,0,0]
			a:28 -> count[2,1,2,1,0,0,0,0,0,0]
			当d = 2时，结果是    count[2,1,2,1,0,0,0,0,0,0]
			再处理形成右边界索引 count[2,3,5,6,6,6,6,6,6,6]
			通过右边界索引可得bucket[1,2,15,24,28,34]
			并将bucket拷贝到a中
		从以上分析可知：
			1、个数总和（基数本身就是0~9有序，因此生成的下标也是有序）是len因此可以转换出当前基数的下标
			2、根据下标装入桶内
			3、根据基数统计个数》转换成下标》装入桶中
	堆排序
		24 15 34 28 1 2  （初始）
			   24
			15    34  
		  28  1  2 
		》第一步先构建一个堆顶向下从大到小排列，但不成序。即初步形成堆顶最大，也为后续操作奠定基础
		》》第一步解析（从最尾端一个非叶子结点（i=len/2-1）开始往前构造局部大顶堆和整体）
		》》i=len/2-1=2; 过程描述：此时局部堆顶节点为‘34’（位置：2），先找到左节点‘2’（下标：i*2+1），
		》》》先左右取最大节点（存在右节点）；将子节点中最大的元素与根元素‘34’比较，并置换最大到局部堆顶
			   24
			15    34  
		  28  1  2 
		
		》》i=i--=1;  过程描述：此时局部堆顶节点为‘15’（位置：1），先找到左节点‘28’（下标：i*2+1），
		》》》先左右取最大节点（存在右节点）；将子节点中最大的元素与根元素‘15’比较，并置换最大到局部堆顶
			   24
			28    34  
		  15  1  2 
		》》》根据刚刚置换的位置，此时的局部堆顶节点为‘15’（位置：3），显然当前节点无法构建顶堆，因为其没有子节点，因此结束此次构建
		       24
			28    34  
		  15  1  2 
		》》i=i--=0;  过程描述：此时局部堆顶节点为‘24’（位置：0），先找到左节点‘28’（下标：i*2+1），
		》》》先左右取最大节点（存在右节点）；将子节点中最大的节点‘34’与根节点‘24’比较，并置换最大到局部堆顶
		       34
			28    24  
		  15  1  2 
		》》》根据刚刚置换的位置，此时的局部堆顶节点为‘24’（位置：2），显然此时的局部堆顶是最大
		       34
			28    24  
		  15  1  2 
		》》结束第一步；总结：（从最尾端一个非叶子结点（i=len/2-1）开始往前构造局部大顶堆和整体）为后续操作奠定基础
		》第二步将堆顶元素和最后一个元素置换，使得此时的尾部最大，尾部置换的范围往前移动，以此构建有序的数列
		》》j=len-1=5；0~5范围内前后置换得：
			   2
			28    24  
		  15  1  34
	    》》》并重新在0~4范围内构建大顶堆
			   28           			28
			2      24      -》     15       24
		  15  1  				2		1
		》》j=4；0~4范围内前后置换得：
			   1
			15    24  
		  2    28  
	    》》》并重新在0~3范围内构建大顶堆
			   24           
			15     1       
		  2    
		》》j=3；0~3范围内前后置换得：
			   2
			15    1  
		  24
	    》》》并重新在0~2范围内构建大顶堆
			   15           
			2      1     
		》》j=2；0~2范围内前后置换得：
			   1           
			2      15  
	    》》》并重新在0~1范围内构建大顶堆
			   2
			1
		》》j=1；0~1范围内前后置换得：
			   1
			2 
	    结果：
			   1
			2     15  
		 24    28    34 
		 
		 从以上分析可知：
			1、先构建一个顶堆，初步形成从上到下大到小排列，但无序。
			2、将堆顶元素置换到末尾，并在0~末尾前一位置范围内构建顶堆在重复第2点的操作，直至有序
		
